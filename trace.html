<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #game-container {
            text-align: center;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(7, 40px);
            grid-gap: 1px;
            background-color: #000;
            padding: 1px;
        }
        .cell {
            width: 40px;
            height: 40px;
            background-color: #fff !important;
            position: relative;
            opacity: 1;
        }
        .error {
            animation: error 0.5s;
        }
        @keyframes error {
            50% { background-color: red; }
        }
        #score {
            margin-top: 20px;
            font-size: 24px;
        }
        #next-pieces {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .piece {
            width: 40px;
            height: 40px;
            background-color: #fff;
            border: 1px solid #000;
            position: relative;
            cursor: pointer;
        }
        .selected {
            border: 2px solid blue;
        }
        #hiscores-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
        canvas {
            display: block;
        }
        .fade-out {
            animation: fadeOut 1s forwards;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .highlight {
            animation: highlight 1s infinite;
        }
        @keyframes highlight {
            50% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="grid"></div>
        <div id="score">Score : 0</div>
        <div id="next-pieces"></div>
        <button id="hiscores-btn">Hiscores</button>
    </div>

    <script>
        const gridSize = 7;
        const cellSize = 40;
        let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
        let score = 0;
        let availablePieces = [];
        let selectedPieceIndex = null;
        let gameOver = false;

        // Initialisation de la grille
        const gridElement = document.getElementById('grid');
        for (let i = 0; i < gridSize * gridSize; i++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.x = i % gridSize;
            cell.dataset.y = Math.floor(i / gridSize);
            cell.addEventListener('click', () => handleCellClick(cell));
            cell.addEventListener('dragover', (e) => e.preventDefault());
            cell.addEventListener('drop', (e) => handleDrop(e, cell));
            gridElement.appendChild(cell);
        }

        // Générer une pièce aléatoire
        function generatePiece() {
            const points = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
            const start = points[Math.floor(Math.random() * 8)];
            let end = points[Math.floor(Math.random() * 8)];
            while (end === start) end = points[Math.floor(Math.random() * 8)];
            return { start, end };
        }

        // Dessiner une pièce dans un élément
        function drawPiece(element, piece, size = cellSize, color = '#000') {
            if (!piece || !piece.start || !piece.end) return;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '1';
            canvas.style.backgroundColor = 'transparent';
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.beginPath();
            const centerX = size / 2;
            const centerY = size / 2;
            const positions = {
                'top-left': [0, 0], 'top': [centerX, 0], 'top-right': [size, 0],
                'right': [size, centerY], 'bottom-right': [size, size],
                'bottom': [centerX, size], 'bottom-left': [0, size], 'left': [0, centerY]
            };
            const [startX, startY] = positions[piece.start];
            const [endX, endY] = positions[piece.end];
            ctx.moveTo(startX, startY);
            ctx.lineTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            element.innerHTML = '';
            element.appendChild(canvas);
        }

        // Initialiser les 5 pièces disponibles
        function initializePieces() {
            availablePieces = Array(5).fill().map(() => generatePiece());
            updatePieces();
        }

        // Mettre à jour l’affichage des pièces disponibles
        function updatePieces() {
            const nextPiecesElement = document.getElementById('next-pieces');
            nextPiecesElement.innerHTML = '';
            availablePieces.forEach((piece, index) => {
                const pieceElement = document.createElement('div');
                pieceElement.classList.add('piece');
                pieceElement.dataset.index = index;
                pieceElement.draggable = true;
                pieceElement.addEventListener('click', () => selectPiece(index));
                pieceElement.addEventListener('dragstart', (e) => handleDragStart(e, index));
                if (selectedPieceIndex === index) pieceElement.classList.add('selected');
                drawPiece(pieceElement, piece);
                nextPiecesElement.appendChild(pieceElement);
            });
            document.getElementById('score').textContent = `Score : ${score}`;
        }

        // Sélectionner une pièce par clic
        function selectPiece(index) {
            selectedPieceIndex = index;
            updatePieces();
        }

        // Gérer le drag start
        function handleDragStart(e, index) {
            e.dataTransfer.setData('pieceIndex', index);
        }

        // Gérer le drop sur une cellule
        function handleDrop(e, cell) {
            e.preventDefault();
            const pieceIndex = parseInt(e.dataTransfer.getData('pieceIndex'));
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            placePiece(x, y, pieceIndex);
        }

        // Gérer le clic sur une cellule
        function handleCellClick(cell) {
            if (selectedPieceIndex === null) return;
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            placePiece(x, y, selectedPieceIndex);
        }

        // Placer une pièce sur la grille
        function placePiece(x, y, pieceIndex) {
            if (gameOver || pieceIndex === null || grid[y][x]) {
                if (grid[y][x]) {
                    const cell = gridElement.children[y * gridSize + x];
                    cell.classList.add('error');
                }
                return;
            }
            const piece = availablePieces[pieceIndex];
            grid[y][x] = piece;
            const cell = gridElement.children[y * gridSize + x];
            drawPiece(cell, piece);
            new Audio('place.mp3').play();
            availablePieces[pieceIndex] = null;
            selectedPieceIndex = null;
            try {
                checkPatterns(x, y);
            } catch (e) {
                console.error("Error in checkPatterns:", e);
            }
            if (availablePieces.every(p => p === null)) {
                initializePieces();
            } else {
                updatePieces();
            }
            if (!canPlacePiece()) endGame();
        }

        // Vérifier si une pièce peut être placée
        function canPlacePiece() {
            return grid.some(row => row.some(cell => !cell));
        }

       // Nouvelle méthode de détection des motifs
// Nouvelle méthode de détection des motifs
function checkPatterns(startX, startY) {
    console.log(`checkPatterns called with startX=${startX}, startY=${startY}`);
    const piece = grid[startY][startX];
    if (!piece) {
        console.error("No piece found at", startX, startY);
        return;
    }

    const directions = {
        'top-left': [[-1, -1], [0, -1], [-1, 0]], // Diagonale, haut, gauche
        'top': [[0, -1]], // Haut
        'top-right': [[1, -1], [0, -1], [1, 0]], // Diagonale, haut, droite
        'right': [[1, 0]], // Droite
        'bottom-right': [[1, 1], [0, 1], [1, 0]], // Diagonale, bas, droite
        'bottom': [[0, 1]], // Bas
        'bottom-left': [[-1, 1], [0, 1], [-1, 0]], // Diagonale, bas, gauche
        'left': [[-1, 0]] // Gauche
    };
    const opposites = {
        'top-left': [['bottom-right'], ['bottom-right', 'bottom'], ['top-right', 'right']],
        'top': [['bottom']],
        'top-right': [['bottom-left'], ['bottom-left', 'bottom'], ['top-left', 'left']],
        'right': [['left']],
        'bottom-right': [['top-left'], ['top-left', 'top'], ['bottom-left', 'left']],
        'bottom': [['top']],
        'bottom-left': [['top-right'], ['top-right', 'top'], ['bottom-right', 'right']],
        'left': [['right']]
    };

    // Fonction pour vérifier si un cycle forme un vrai motif fermé
    function isValidClosedPattern(path) {
        if (path.length < 2) {
            console.log("Path too short:", path);
            return false;
        }

        // Construire la liste des points dans l'ordre du chemin
        const points = [];
        for (let i = 0; i < path.length - 1; i++) { // Exclure la dernière entrée (répétition de la première)
            const [x, y] = path[i];
            const piece = grid[y][x];
            const nextPiece = grid[path[i + 1][1]][path[i + 1][0]];

            // Ajouter les points dans l'ordre de connexion
            const currentDir = piece.end;
            const nextDir = nextPiece.start;
            points.push(currentDir);

            // Vérifier que les directions se connectent correctement
            const expectedNextDir = opposites[currentDir] && opposites[currentDir][0] ? opposites[currentDir][0][0] : null;
            if (!nextDir || !expectedNextDir || !opposites[currentDir] || !opposites[currentDir][0].includes(nextDir)) {
                console.log(`Invalid connection at step ${i}: ${currentDir} → ${nextDir}, expected ${expectedNextDir}`);
                return false;
            }
        }

        // Ajouter le premier point pour boucler
        points.push(points[0]);

        // Vérifier que les points forment une boucle continue
        for (let i = 0; i < points.length - 1; i++) {
            const currentPoint = points[i];
            const nextPoint = points[i + 1];
            const expectedNextPoint = opposites[currentPoint] && opposites[currentPoint][0] ? opposites[currentPoint][0][0] : null;
            if (!expectedNextPoint || expectedNextPoint !== nextPoint) {
                console.log(`Points do not form a closed loop: ${currentPoint} → ${nextPoint}, expected ${expectedNextPoint}`);
                return false;
            }
        }

        console.log("Points in cycle form a closed loop:", points);
        return true;
    }

    // Fonction pour explorer un chemin
    function explorePath(startX, startY, initialDir) {
        console.log(`Exploring path from ${startX},${startY} with initialDir=${initialDir}`);
        let currentX = startX;
        let currentY = startY;
        let currentDir = initialDir;
        const visited = new Set();
        const path = [[startX, startY]];
        visited.add(`${startX},${startY}`);

        while (true) {
            const currentPiece = grid[currentY][currentX];
            let nextDir;

            // Déterminer la direction suivante
            const possibleDirs = [currentPiece.start, currentPiece.end].filter(dir => dir !== currentDir);
            console.log(`Possible directions from ${currentX},${currentY}:`, possibleDirs);
            nextDir = possibleDirs.find(dir => {
                const nextNeighbors = directions[dir].map(([dx, dy], idx) => {
                    const nx = currentX + dx;
                    const ny = currentY + dy;
                    const valid = nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize;
                    const expectedStarts = opposites[dir] && opposites[dir][idx] ? opposites[dir][idx] : [];
                    return { x: nx, y: ny, valid, expectedStarts, dir };
                });
                return nextNeighbors.some(n => n.valid && grid[n.y] && grid[n.y][n.x] && (n.expectedStarts.includes(grid[n.y][n.x].start) || n.expectedStarts.includes(grid[n.y][n.x].end)));
            });

            if (!nextDir) {
                console.log(`No next direction found from ${currentX},${currentY}`);
                break;
            }

            const nextNeighbors = directions[nextDir].map(([dx, dy], idx) => {
                const nx = currentX + dx;
                const ny = currentY + dy;
                const valid = nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize;
                const expectedStarts = opposites[nextDir] && opposites[nextDir][idx] ? opposites[nextDir][idx] : [];
                return { x: nx, y: ny, valid, expectedStarts, dir: nextDir };
            });

            const nextNeighbor = nextNeighbors.find(n => n.valid && grid[n.y] && grid[n.y][n.x] && (n.expectedStarts.includes(grid[n.y][n.x].start) || n.expectedStarts.includes(grid[n.y][n.x].end)));
            if (!nextNeighbor) {
                console.log(`No valid neighbor found for direction ${nextDir}`);
                break;
            }

            currentX = nextNeighbor.x;
            currentY = nextNeighbor.y;
            currentDir = nextDir;

            path.push([currentX, currentY]);

            if (currentX === startX && currentY === startY) {
                console.log("Cycle detected:", path);
                if (isValidClosedPattern(path)) {
                    console.log("Valid closed pattern detected");
                    return path;
                }
                console.log("Invalid closed pattern");
                break;
            }

            if (visited.has(`${currentX},${currentY}`)) {
                console.log(`Cycle non fermé at ${currentX},${currentY}`);
                break;
            }
            visited.add(`${currentX},${currentY}`);
        }
        return null;
    }

    // Vérifier les cases correspondant à start et end
    const startNeighbors = directions[piece.start].map(([dx, dy], idx) => {
        const nx = startX + dx;
        const ny = startY + dy;
        const valid = nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize;
        return { x: nx, y: ny, valid, expectedEnds: opposites[piece.start] ? opposites[piece.start][idx] : [] };
    });
    const endNeighbors = directions[piece.end].map(([dx, dy], idx) => {
        const nx = startX + dx;
        const ny = startY + dy;
        const valid = nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize;
        return { x: nx, y: ny, valid, expectedStarts: opposites[piece.end] ? opposites[piece.end][idx] : [] };
    });

    const startOccupied = startNeighbors.some(n => n.valid && grid[n.y] && grid[n.y][n.x]);
    const endOccupied = endNeighbors.some(n => n.valid && grid[n.y] && grid[n.y][n.x]);
    if (!startOccupied || !endOccupied) {
        console.log("No occupied neighbors for start or end");
        return;
    }

    const startPaths = startNeighbors.filter(n => n.valid && grid[n.y] && grid[n.y][n.x] && n.expectedEnds.includes(grid[n.y][n.x].end));
    const endPaths = endNeighbors.filter(n => n.valid && grid[n.y] && grid[n.y][n.x] && n.expectedStarts.includes(grid[n.y][n.x].start));

    for (const startNeighbor of startPaths) {
        const path = explorePath(startNeighbor.x, startNeighbor.y, piece.start);
        if (path) {
            animatePattern(path);
            return;
        }
    }

    for (const endNeighbor of endPaths) {
        const path = explorePath(endNeighbor.x, endNeighbor.y, piece.end);
        if (path) {
            animatePattern(path);
            return;
        }
    }
}
        // Animer le motif détecté
        function animatePattern(path) {
            path.forEach(([x, y]) => {
                const cell = gridElement.children[y * gridSize + x];
                cell.classList.add('fade-out');
                const piece = grid[y][x];
                const highlightCanvas = document.createElement('canvas');
                highlightCanvas.width = cellSize;
                highlightCanvas.height = cellSize;
                highlightCanvas.style.position = 'absolute';
                highlightCanvas.style.top = '0';
                highlightCanvas.style.left = '0';
                highlightCanvas.style.zIndex = '2';
                highlightCanvas.classList.add('highlight');
                drawPiece(highlightCanvas, piece, cellSize, 'red');
                cell.appendChild(highlightCanvas);
            });

            setTimeout(() => {
                path.forEach(([x, y]) => {
                    grid[y][x] = null;
                    const cell = gridElement.children[y * gridSize + x];
                    cell.innerHTML = '';
                    cell.classList.remove('fade-out', 'highlight');
                    cell.style.backgroundColor = '#fff';
                    cell.style.opacity = '1';
                });
                const points = path.length + Math.floor(path.length / 5) * 5;
                score += points;
                updatePieces();
            }, 1000);

            new Audio('pattern.wav').play();
        }

        // Fin de partie
        function endGame() {
            gameOver = true;
            addHighScore(score);
        }

        // Charger les scores
        function loadHighScores() {
            return fetch('https://blomig.com/api/trace/scores.php?v=' + Date.now(), {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                cache: 'no-cache'
            })
            .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
            .then(highScores => {
                while (highScores.length < 10) highScores.push(["AAAAA", 0]);
                return highScores;
            })
            .catch(() => [["AAAAA", 0], ["BBBBB", 0], ["CCCCC", 0], ["DDDDD", 0], ["EEEEE", 0], ["FFFFF", 0], ["GGGGG", 0], ["HHHHH", 0], ["IIIII", 0], ["JJJJJ", 0]]);
        }

        // Sauvegarder les scores
        function saveHighScores(newScore) {
            return fetch('https://blomig.com/api/trace/scores.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newScore)
            })
            .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(`HTTP error! status: ${response.status}, message: ${err.error}`)))
            .catch(error => { console.error("Erreur sauvegarde:", error); throw error; });
        }

        // Ajouter un score
        function addHighScore(score) {
            let name = prompt("Partie terminée ! Entrez vos initiales (5 lettres max) :", "AAAAA");
            if (name) {
                name = name.slice(0, 5).padEnd(5, " ").toUpperCase();
                loadHighScores().then(highScores => {
                    highScores.push([name, score]);
                    highScores.sort((a, b) => b[1] - a[1]);
                    highScores = highScores.slice(0, 10);
                    saveHighScores({ name, score })
                        .then(() => alert("Score sauvegardé !"))
                        .catch(() => alert("Erreur lors de la sauvegarde du score."));
                });
            }
        }

        // Afficher les hiscores
        document.getElementById('hiscores-btn').addEventListener('click', () => {
            loadHighScores().then(highScores => {
                const scoresText = highScores.map(([name, score], i) => `${i + 1}. ${name} - ${score}`).join('\n');
                alert('Meilleurs scores :\n' + scoresText);
            });
        });

        // Démarrer le jeu
        initializePieces();
    </script>
</body>
</html>
