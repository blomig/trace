<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Motifs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #game-container {
            text-align: center;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-gap: 1px;
            background-color: #000;
            padding: 1px;
        }
        .cell {
            width: 40px;
            height: 40px;
            background-color: #fff;
            position: relative;
        }
        #score {
            margin-top: 20px;
            font-size: 24px;
        }
        #next-pieces {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .cell, #current-piece, #next-piece {
    width: 40px;
    height: 40px;
    background-color: #fff;
    border: 1px solid #000; /* Ajout d’une bordure pour voir les limites */
    position: relative; /* Pour que le canvas s’aligne bien */
    overflow: visible;
}
#next-piece {
    width: 20px;
    height: 20px;
}
        #hiscores-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
        canvas { display: none; } /* Pour dessiner les traits dynamiquement */
        .blink {
    animation: blink 0.5s infinite;
}
@keyframes blink {
    50% { opacity: 0; }
}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="grid"></div>
        <div id="score">Score : 0</div>
        <div id="next-pieces">
            <div id="current-piece"></div>
            <div id="next-piece"></div>
        </div>
        <button id="hiscores-btn">Hiscores</button>
    </div>

   <script>
    const gridSize = 10;
    const cellSize = 40;
    let grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
    let score = 0;
    let currentPiece = null;
    let nextPiece = null;
    let gameOver = false;

    // Initialisation de la grille (inchangée)
    const gridElement = document.getElementById('grid');
    for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.addEventListener('click', () => placePiece(i % gridSize, Math.floor(i / gridSize)));
        gridElement.appendChild(cell);
    }

    // Générer une pièce (inchangé)
    function generatePiece() {
        const points = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
        const start = points[Math.floor(Math.random() * 8)];
        let end = points[Math.floor(Math.random() * 8)];
        while (end === start) end = points[Math.floor(Math.random() * 8)];
        return { start, end };
    }

    function drawPiece(element, piece, size = cellSize) {
    if (!piece || !piece.start || !piece.end) {
        console.error('Invalid piece:', piece);
        return;
    }
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.zIndex = '1';
    canvas.style.display = 'block';
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, size, size);
    ctx.beginPath();
    const centerX = size / 2;
    const centerY = size / 2;
    const positions = {
        'top-left': [0, 0], 'top': [centerX, 0], 'top-right': [size, 0],
        'right': [size, centerY], 'bottom-right': [size, size],
        'bottom': [centerX, size], 'bottom-left': [0, size], 'left': [0, centerY]
    };
    const [startX, startY] = positions[piece.start];
    const [endX, endY] = positions[piece.end];
    ctx.moveTo(startX, startY);
    ctx.lineTo(centerX, centerY);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    element.innerHTML = '';
    element.appendChild(canvas);
}
       
    // Placer une pièce
function placePiece(x, y) {
    if (gameOver || !currentPiece || grid[y][x]) return;
    grid[y][x] = currentPiece;
    const cell = gridElement.children[y * gridSize + x];
    drawPiece(cell, currentPiece); // Dessine la pièce avec ses traits
    new Audio('place.mp3').play(); // À remplacer
    checkPatterns(); // Vérifie les motifs après placement
    currentPiece = nextPiece;
    nextPiece = generatePiece();
    updatePieces();
    if (!canPlacePiece()) endGame();
}

function checkPatterns() {
    const visited = new Set();
    const parent = new Map();
    let cycleFound = false;
    const cyclePieces = new Set();

    console.log('Starting pattern check...');
    for (let y = 0; y < gridSize && !cycleFound; y++) {
        for (let x = 0; x < gridSize && !cycleFound; x++) {
            if (grid[y][x] && !visited.has(`${x},${y}`)) {
                console.log(`Starting DFS from (${x},${y})`);
                cycleFound = dfs(x, y, null, visited, parent, cyclePieces);
                if (cycleFound) break;
            }
        }
    }

    if (cycleFound) {
        console.log('Cycle found! Pieces involved:', cyclePieces);
        cyclePieces.forEach(pos => {
            const [x, y] = pos.split(',').map(Number);
            const cell = gridElement.children[y * gridSize + x];
            cell.classList.add('blink');
        });
        setTimeout(() => {
            cyclePieces.forEach(pos => {
                const [x, y] = pos.split(',').map(Number);
                grid[y][x] = null;
                const cell = gridElement.children[y * gridSize + x];
                cell.innerHTML = '';
                cell.classList.remove('blink');
            });
            score += cyclePieces.size * 10;
            updatePieces();
        }, 500);
        new Audio('pattern.wav').play();
    } else {
        console.log('No cycle found.');
    }
}

function dfs(x, y, prev, visited, parent, cyclePieces) {
    const key = `${x},${y}`;
    console.log(`Visiting (${x},${y})`);
    visited.add(key);
    parent.set(key, prev);

    const piece = grid[y][x];
    const neighbors = getNeighbors(x, y, piece);

    for (const [nx, ny, port] of neighbors) {
        const nKey = `${nx},${ny}`;
        console.log(`Checking neighbor (${nx},${ny}) from (${x},${y})`);
        if (!grid[ny][nx]) continue;

        if (!visited.has(nKey)) {
            console.log(`Neighbor (${nx},${ny}) not visited, exploring...`);
            if (dfs(nx, ny, key, visited, parent, cyclePieces)) {
                if (!cyclePieces.size) markCycle(key, parent, cyclePieces);
                cyclePieces.add(key);
                return true;
            }
        } else if (nKey !== prev && parent.has(nKey)) {
            console.log(`Cycle detected! From (${x},${y}) to (${nx},${ny})`);
            markCycle(key, parent, cyclePieces);
            cyclePieces.add(key);
            return true;
        }
    }
    return false;
}

function getNeighbors(x, y, piece) {
    const connections = [];
    const opposites = {
        'top': ['bottom', 'bottom-left', 'bottom-right'],
        'bottom': ['top', 'top-left', 'top-right'],
        'left': ['right', 'top-right', 'bottom-right'],
        'right': ['left', 'top-left', 'bottom-left']
    };
    const dirs = [
        [0, -1, 'top'], [1, 0, 'right'], [0, 1, 'bottom'], [-1, 0, 'left']
    ];

    console.log(`Checking neighbors for piece at (${x},${y}):`, piece);
    for (const [dx, dy, dir] of dirs) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const neighbor = grid[ny][nx];
            if (neighbor) {
                const expectedStarts = opposites[dir];
                const expectedEnds = opposites[dir];
                console.log(`Neighbor at (${nx},${ny}):`, neighbor, `Direction: ${dir}`);
                console.log(`Piece end: ${piece.end}, Neighbor start: ${neighbor.start}, Expected starts:`, expectedStarts);
                console.log(`Piece start: ${piece.start}, Neighbor end: ${neighbor.end}, Expected ends:`, expectedEnds);
                if (piece.end === dir && expectedStarts.includes(neighbor.start)) {
                    console.log(`Connection found: (${x},${y}) end to (${nx},${ny}) start`);
                    connections.push([nx, ny, dir]);
                }
                if (piece.start === dir && expectedEnds.includes(neighbor.end)) {
                    console.log(`Connection found: (${x},${y}) start to (${nx},${ny}) end`);
                    connections.push([nx, ny, dir]);
                }
            }
        }
    }
    console.log(`Connections for (${x},${y}):`, connections);
    return connections;
}

function markCycle(start, parent, cyclePieces) {
    let current = start;
    while (current && !cyclePieces.has(current)) {
        cyclePieces.add(current);
        current = parent.get(current);
    }
}

    // Mettre à jour l’affichage des pièces
function updatePieces() {
    const currentElement = document.getElementById('current-piece');
    const nextElement = document.getElementById('next-piece');
    drawPiece(currentElement, currentPiece, cellSize); // Pièce actuelle
    drawPiece(nextElement, nextPiece, 20); // Pièce suivante
    document.getElementById('score').textContent = `Score : ${score}`;
}

    // Vérifier si une pièce peut être placée
    function canPlacePiece() {
        return grid.some(row => row.some(cell => !cell));
    }

    // Fin de partie
    function endGame() {
        gameOver = true;
        addHighScore(score);
    }

    // Charger les scores
    function loadHighScores() {
        return fetch('https://blomig.com/api/trace/scores.php?v=' + Date.now(), {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
            cache: 'no-cache'
        })
        .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
        .then(highScores => {
            while (highScores.length < 10) highScores.push(["AAAAA", 0]);
            return highScores;
        })
        .catch(() => [["AAAAA", 0], ["BBBBB", 0], ["CCCCC", 0], ["DDDDD", 0], ["EEEEE", 0], ["FFFFF", 0], ["GGGGG", 0], ["HHHHH", 0], ["IIIII", 0], ["JJJJJ", 0]]);
    }

    // Sauvegarder les scores
    function saveHighScores(newScore) {
        return fetch('https://blomig.com/api/trace/scores.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newScore)
        })
        .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(`HTTP error! status: ${response.status}, message: ${err.error}`)))
        .catch(error => { console.error("Erreur sauvegarde:", error); throw error; });
    }

    // Ajouter un score
    function addHighScore(score) {
        let name = prompt("Partie terminée ! Entrez vos initiales (5 lettres max) :", "AAAAA");
        if (name) {
            name = name.slice(0, 5).padEnd(5, " ").toUpperCase();
            loadHighScores().then(highScores => {
                highScores.push([name, score]);
                highScores.sort((a, b) => b[1] - a[1]);
                highScores = highScores.slice(0, 10);
                saveHighScores({ name, score })
                    .then(() => alert("Score sauvegardé !"))
                    .catch(() => alert("Erreur lors de la sauvegarde du score."));
            });
        }
    }

    // Afficher les hiscores
    document.getElementById('hiscores-btn').addEventListener('click', () => {
        loadHighScores().then(highScores => {
            const scoresText = highScores.map(([name, score], i) => `${i + 1}. ${name} - ${score}`).join('\n');
            alert('Meilleurs scores :\n' + scoresText);
        });
    });

    // Démarrer le jeu
    currentPiece = generatePiece();
    nextPiece = generatePiece();
    updatePieces();
</script>
</body>
</html>
