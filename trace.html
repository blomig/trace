<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Detection Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-gap: 2px;
            background-color: #ccc;
            padding: 5px;
        }
        .cell {
            width: 50px;
            height: 50px;
            background-color: white;
            border: 1px solid black;
            cursor: pointer;
        }
        .cell.pattern {
            background-color: #90ee90; /* Vert clair pour les motifs détectés */
        }
        #inventory {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        .piece {
            width: 50px;
            height: 50px;
            border: 1px solid black;
            cursor: pointer;
            background-color: #e0e0e0;
        }
        .piece.selected {
            border: 2px solid blue;
        }
        #controls {
            margin: 20px;
        }
        #controls button {
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <h1>Pattern Detection Game</h1>
    <div id="game-container">
        <div id="grid"></div>
        <div id="inventory"></div>
        <div id="controls">
            <button onclick="nextTurn()">Next Turn</button>
            <button onclick="clearGrid()">Clear Grid</button>
        </div>
    </div>

    <script>
        // Taille de la grille
        const gridSize = 7;

        // Initialisation de la grille (7x7)
        let grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));

        // Liste des points possibles
        const pointsList = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];

        // Liste des traits possibles (start, end)
        const possibleTraits = [
            { start: 'top-left', end: 'left' },
            { start: 'top-right', end: 'right' },
            { start: 'bottom-left', end: 'left' },
            { start: 'bottom-right', end: 'right' },
            { start: 'top', end: 'right' },
            { start: 'left', end: 'bottom' },
            { start: 'bottom', end: 'right' },
            { start: 'left', end: 'top' },
            { start: 'top-right', end: 'bottom-right' },
            { start: 'bottom-left', end: 'top-left' }
        ];

        // Positions des points dans une cellule (pour le dessin)
        const pointPositions = {
            'top-left': { x: 5, y: 5 },
            'top': { x: 25, y: 5 },
            'top-right': { x: 45, y: 5 },
            'right': { x: 45, y: 25 },
            'bottom-right': { x: 45, y: 45 },
            'bottom': { x: 25, y: 45 },
            'bottom-left': { x: 5, y: 45 },
            'left': { x: 5, y: 25 }
        };

        // Position du centre de la cellule
        const centerPosition = { x: 25, y: 25 };

        // Pièces disponibles à chaque tour
        let availablePieces = [];
        let selectedPieceIndex = null;

        // Directions possibles pour chaque point
        const directions = {
            'top-left': [[-1, -1], [0, -1], [-1, 0]], // Diagonale, haut, gauche
            'top': [[0, -1]], // Haut
            'top-right': [[1, -1], [0, -1], [1, 0]], // Diagonale, haut, droite
            'right': [[1, 0]], // Droite
            'bottom-right': [[1, 1], [0, 1], [1, 0]], // Diagonale, bas, droite
            'bottom': [[0, 1]], // Bas
            'bottom-left': [[-1, 1], [0, 1], [-1, 0]], // Diagonale, bas, gauche
            'left': [[-1, 0]] // Gauche
        };

        // Points opposés pour chaque direction
        const opposites = {
            'top-left': { diagonal: ['bottom-right'], up: ['bottom-left', 'bottom'], left: ['top-right', 'right'] },
            'top': { up: ['bottom'] },
            'top-right': { diagonal: ['bottom-left'], up: ['bottom-right', 'bottom'], right: ['top-left', 'left'] },
            'right': { right: ['left', 'top-left', 'bottom-left'] },
            'bottom-right': { diagonal: ['top-left'], down: ['top-right', 'top'], right: ['bottom-left', 'left'] },
            'bottom': { down: ['top'] },
            'bottom-left': { diagonal: ['top-right'], down: ['top-left', 'top'], left: ['bottom-right', 'right'] },
            'left': { left: ['right', 'top-right', 'bottom-right'] }
        };

        // Fonction pour dessiner un trait dans un canvas, en passant par le centre
        function drawTrait(canvas, start, end) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();

            const startPos = pointPositions[start];
            const endPos = pointPositions[end];
            const centerPos = centerPosition;

            // Segment 1 : start → centre
            ctx.moveTo(startPos.x, startPos.y);
            ctx.lineTo(centerPos.x, centerPos.y);

            // Segment 2 : centre → end
            ctx.lineTo(endPos.x, endPos.y);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Fonction pour afficher la grille dans l'interface HTML
        function renderGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = ''; // Vider la grille

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cellElement = document.createElement('div');
                    cellElement.className = 'cell';
                    cellElement.dataset.x = x;
                    cellElement.dataset.y = y;

                    const canvas = document.createElement('canvas');
                    canvas.width = 50;
                    canvas.height = 50;
                    cellElement.appendChild(canvas);

                    if (grid[y][x]) {
                        const piece = grid[y][x];
                        drawTrait(canvas, piece.start, piece.end);
                        if (piece.isPartOfPattern) {
                            cellElement.classList.add('pattern');
                        }
                    }

                    cellElement.addEventListener('click', handleCellClick);
                    gridElement.appendChild(cellElement);
                }
            }
        }

        // Fonction pour afficher les pièces disponibles
        function renderInventory() {
            const inventoryElement = document.getElementById('inventory');
            inventoryElement.innerHTML = ''; // Vider l'inventaire

            availablePieces.forEach((piece, index) => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'piece';
                if (index === selectedPieceIndex) {
                    pieceElement.classList.add('selected');
                }

                const canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 50;
                drawTrait(canvas, piece.start, piece.end);
                pieceElement.appendChild(canvas);

                pieceElement.addEventListener('click', () => {
                    selectedPieceIndex = index;
                    renderInventory();
                });

                inventoryElement.appendChild(pieceElement);
            });
        }

        // Fonction pour tirer 5 pièces au hasard
        function drawPieces() {
            availablePieces = [];
            for (let i = 0; i < 5; i++) {
                const randomTrait = possibleTraits[Math.floor(Math.random() * possibleTraits.length)];
                availablePieces.push({ ...randomTrait });
            }
            selectedPieceIndex = null;
            renderInventory();
        }

        // Gestionnaire de clic sur une cellule
        function handleCellClick(event) {
            if (selectedPieceIndex === null) {
                console.log("No piece selected");
                return;
            }

            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);
            const piece = availablePieces[selectedPieceIndex];
            if (placePiece(x, y, piece.start, piece.end)) {
                // Retirer la pièce utilisée de l'inventaire
                availablePieces.splice(selectedPieceIndex, 1);
                selectedPieceIndex = null;
                renderInventory();
            }
        }

        // Fonction pour placer une pièce sur la grille
        function placePiece(x, y, start, end) {
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
                console.error(`Invalid position: (${x}, ${y})`);
                return false;
            }
            if (grid[y][x]) {
                console.error(`Position (${x}, ${y}) already occupied`);
                return false;
            }
            if (!pointsList.includes(start) || !pointsList.includes(end)) {
                console.error(`Invalid start or end point: start=${start}, end=${end}`);
                return false;
            }

            // Placer la pièce dans la grille
            grid[y][x] = { start, end, isPartOfPattern: false };
            console.log(`Placed piece at (${x}, ${y}) with start=${start}, end=${end}`);

            // Afficher la grille après placement
            renderGrid();

            // Vérifier les motifs après placement
            checkPatterns(x, y);
            return true;
        }

        // Fonction pour vérifier les motifs après placement d'une pièce
        function checkPatterns(startX, startY) {
            console.log(`checkPatterns called with startX=${startX}, startY=${startY}`);
            const piece = grid[startY][startX];
            if (!piece) {
                console.error("No piece found at", startX, startY);
                return;
            }
            if (!piece.start || !piece.end) {
                console.error(`Invalid piece at (${startX}, ${startY}): start=${piece.start}, end=${piece.end}`);
                return;
            }

            // Stocker les traits posés dans une liste
            const traits = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!grid[y][x]) continue;
                    const piece = grid[y][x];
                    if (!piece.start || !piece.end) {
                        console.error(`Invalid piece at (${x}, ${y}): start=${piece.start}, end=${piece.end}`);
                        continue;
                    }
                    traits.push({ x, y, start: piece.start, end: piece.end });
                }
            }

            console.log("Traits:", traits);

            // Fonction pour trouver un cycle fermé à partir d'un point de départ
            function findCycle(startNode) {
                const visited = new Set();
                const parent = new Map();
                const path = [];
                const positionsPath = [];

                function dfs(node, startNode) {
                    visited.add(node);
                    path.push(node);

                    const [currentPoint, pieceKey] = node.split('@');
                    const [x, y] = pieceKey.split(',').map(Number);
                    positionsPath.push(pieceKey);

                    // Trouver les directions possibles pour le point actuel
                    const dirList = directions[currentPoint] || [];
                    let foundNext = false;

                    for (let [dx, dy] of dirList) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx]) {
                            const neighborKey = `${nx},${ny}`;
                            const neighborTrait = traits.find(t => t.x === nx && t.y === ny);
                            if (!neighborTrait) continue;
                            const neighborPoints = new Set([neighborTrait.start, neighborTrait.end]);
                            const oppositePoints = opposites[currentPoint] || {};
                            const direction = dirList.indexOf([dx, dy]) === 0 ? 'diagonal' : (dirList.indexOf([dx, dy]) === 1 ? (oppositePoints.up || oppositePoints.down) : (oppositePoints.left || oppositePoints.right));
                            const oppositePointList = Array.isArray(oppositePoints[direction]) ? oppositePoints[direction] : (oppositePoints[direction] ? [oppositePoints[direction]] : []);
                            if (oppositePointList) {
                                for (let oppositePoint of oppositePointList) {
                                    if (oppositePoint && neighborPoints.has(oppositePoint)) {
                                        const nextNode = `${oppositePoint}@${neighborKey}`;
                                        if (!visited.has(nextNode)) {
                                            parent.set(nextNode, node);
                                            if (dfs(nextNode, startNode)) {
                                                foundNext = true;
                                                break;
                                            }
                                        } else if (nextNode === startNode && path.length >= 3) { // Cycle fermé trouvé
                                            path.push(nextNode);
                                            positionsPath.push(neighborKey);
                                            foundNext = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (foundNext) break;
                        }
                    }

                    if (!foundNext) {
                        path.pop();
                        positionsPath.pop();
                        visited.delete(node);
                    }
                    return foundNext;
                }

                // Essayer de trouver un cycle à partir du point de départ
                visited.clear();
                path.length = 0;
                positionsPath.length = 0;
                parent.clear();
                if (dfs(startNode, startNode)) {
                    return positionsPath;
                }

                return null;
            }

            // Essayer de trouver tous les cycles possibles à partir des deux points de la pièce posée
            const startPieceKey = `${startX},${startY}`;
            const startPoints = [`${piece.start}@${startPieceKey}`, `${piece.end}@${startPieceKey}`];
            const allPaths = [];

            for (let startPoint of startPoints) {
                let cycle = findCycle(startPoint);
                while (cycle) {
                    // Ajouter le cycle trouvé à la liste des chemins
                    allPaths.push(cycle.slice(0, -1)); // Exclure la dernière entrée (répétition de la première)
                    // Recommencer la recherche pour trouver d'autres cycles
                    cycle = findCycle(startPoint);
                }
            }

            // Si aucun cycle n'est trouvé, sortir
            if (allPaths.length === 0) {
                console.log("No cycles found");
                return;
            }

            console.log("Cycles found:", allPaths);

            // Traiter chaque cycle trouvé
            for (let path of allPaths) {
                // Marquer les positions impliquées dans un motif
                const uniquePositions = new Set(path);
                uniquePositions.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    if (grid[y][x]) {
                        grid[y][x].isPartOfPattern = true;
                    }
                });

                // Convertir les positions en coordonnées pour animatePattern
                const animatePath = Array.from(uniquePositions).map(key => {
                    const [x, y] = key.split(',').map(Number);
                    return [x, y];
                });

                if (animatePath.length > 0) {
                    animatePattern(animatePath);
                }
            }

            // Mettre à jour l'affichage après détection des motifs
            renderGrid();
        }

        // Fonction pour animatePattern (marque les cases du motif détecté)
        function animatePattern(path) {
            console.log("Pattern detected:", path);
            // L'animation est déjà gérée par la mise à jour de isPartOfPattern et renderGrid
        }

        // Fonction pour réinitialiser la grille et passer au tour suivant
        function nextTurn() {
            drawPieces();
        }

        // Fonction pour réinitialiser la grille
        function clearGrid() {
            grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
            availablePieces = [];
            selectedPieceIndex = null;
            renderGrid();
            renderInventory();
        }

        // Afficher la grille initiale et tirer les premières pièces
        renderGrid();
        drawPieces();
    </script>
</body>
</html>
